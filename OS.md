# Computer System
## 深入理解计算机系统
#### 第一章 计算机系统漫游
### Part1_程序结构和执行
#### 第二章 信息的表示和处理
##### 十六进制表示法
- 描述基本的二进制到十进制再到十六进制之间的互相转换规则
- 这里可以默认一个十六进制字符相当于四个二进制字符的排列组合
##### 字数据大小
- 每台机器都有一个字长，表示其虚拟地址空间的大小(32位的机器，其虚拟地址空间就是($2^{32}-1$)字节，该机器上的程序最多访问$2^{32}$个字节)
- 描述各个类型的数据再内存中所占用的空间大小(普遍一单位内存可存储八字节的数据(即一字节))
##### 寻址与字节顺序
- 对应数据类型的数据在内存中的某一地址开始存储该类型的字节大小(默认每一个内存地址可存储一字节大小的数据)
- 对一个w位的int数据类型，则该数据由w个位进行表示，那么他的最高有效位为第一个位，最低有效位为最后一个位
- 以字节为单位，同2处道理，可以得出最高有效字节与最低有效字节
- 那么按照从最高位开始存储的方法称为大端法，最低位开始存储的方法称为小端法

##### 布尔代数
- . ~逻辑NO，&逻辑AND，|逻辑OR，^逻辑异或(表示当x或y为真的时候，x和y不同时为真)

##### 位运算
- 对十六进制的参数进行逻辑运算时可以通过先将该参数转化为二进制参数再逐个进行位运算得出结果，再进行十六进制转化可得出最终结果。

##### 位移运算
- 左移运算：对一组二进制数组进行左移，丢弃最高的位，在低位处补充0
- 右移运算：机器支持两种形式的运算
  - 逻辑右移：在左端补充0
  - 算数右移：在左端补充最高有效位的值

##### 无符号数编码
- 补码：将一个无符号整数数据类型为w位，可将该向量写成$\overrightarrow{x} = \begin{bmatrix}x_{w-1} & x_{w-2} & ... & x_{0}\end{bmatrix}$,那么对应的解码值为$$B2U_{w}(\overrightarrow{x}) = \displaystyle\sum\limits_{i=0}^{w-1}x_i2^i$$

##### 补码编码
- 将一个有符号整数数据类型为w位，可将该向量写成$\overrightarrow{x} = \begin{bmatrix}x_{w-1} & x_{w-2} & ... & x_{0}\end{bmatrix}$，那么对应的解码值为$$B2T_{w}(\overrightarrow{x}) = -x_{w-1}2^{w-1} + \displaystyle\sum\limits_{i=0}^{w-2}x_i2^i$$
- 其他表达方式
  - 反码：$$B2O_{w}(\overrightarrow{x}) = -x_{w-1}(2^{w-1}-1) + \displaystyle\sum\limits_{i=0}^{w-2}x_i2^i$$
  - 原码：$$B2S_{w}(\overrightarrow{x}) = (-1)^{x_{w-1}}\cdot \displaystyle\sum\limits_{i=0}^{w-2}x_i2^i$$

##### 有符号与无符号之间的转换
- 结论：在支持强制类型转换的语言中，发生强制类型转换时，所转换的数据的数值可能发生改变，但位模式不会发生改变。
- 可以推导出将补码转换为无符号数公式：$$T2U_w(x) = \begin{cases} x+2^w,x<0 \\ x, x >= 0\end{cases}$$
- 无符号转换为补码：$$U2T_w(x) = \begin{cases} x-2^w,x>TMax_w \\ x, x <= TMax_w\end{cases}$$

##### 截断数字
- 截断无符号数：令$x=B2U_w(\overrightarrow{x}),x^` = B2U_w(\overrightarrow{x^`})$,则$x^` = x mode 2^k$
- 截断补码数值：令$x=B2U_w(\overrightarrow{x}),x^` = B2U_w(\overrightarrow{x^`})$,则$x^` = U2T_k(x mode 2^k)$

##### 整数运算
- 无符号加法：$$x +_w^u y = \begin{cases} x + y, x+y<2^w 正常\\ x+y-2^w, 2^w <= x+y <= 2^{w+1} 溢出\end{cases}$$
- 无符号求反：$$-_w^u x = \begin{cases} x, x = 0\\ 2^w-x, x>0\end{cases}$$
- 补码加法：$$x +_w^t y = \begin{cases} x + y - 2^w, 2^{w-1} <= x+y 正溢出 \\ x + y, -2^{w-1}<=x+y<2^{w-1} 正常\\ x+y+2^w, x+y <= -2^{w+1} 负溢出\end{cases}$$
- 补码的非：$$-_w^t x = \begin{cases} TMin_w, x = TMin_w\\ -x, x>TMin_w\end{cases}$$
- 无符号乘法：$$x*_w^uy = (x*y) \% 2^w$$
- 补码乘法：$$x*_w^ty = U2T_w((x*y) \% 2^w)$$
- 补码乘法与无符号乘法之间的关系：$$(T2B_w)(x *_w^t y) = (U2B_w)(x *_w^u y)$$
- 与2的幂相乘的无符号乘法：$$x<<k = x *_w^u 2^k$$
- 与2的幂相乘的补码乘法：$$x<<k = x *_w^t 2^k$$
- 除以2的无符号除法：$$x>>k = \lfloor x/2^k \rfloor$$
- 除以2的补码除法：$$x>>k = \lfloor x/2^k \rfloor$$

##### 浮点值
- IEEE浮点格式：$V = (-1)^s*M*2^E$
  - s为符号编码
  - M为尾数，表示一个二进制小数
  - E为阶码，对浮点数进行加权

#### 第三章 程序的机器级表示
##### 操作数指示符
- 大多数的指令都包含多个操作数，以下是三种类型的操作数
  - 立即数：用于表示常数，在ATT格式中书写为$\$0xFF$ 
  - 寄存器：表示16个寄存器中的某一个操作
  - 内存引用：根据计算出来的地址访问某个内存位置

##### 异数的数据结构
- 联合(Union)与结构(struct)的差别：
  - 两个定义数据类型的定义方式相同
  - 两个数据类型的指针位置相同
  - 联合内部的数据类型不会去计算偏移量，而结构会计算内部数据类型的偏移量来对数据进行存储

#### 第四章 处理器体系结构
##### Y86-64 指令
> Y86-64指令集是X86-64指令集的一个子集
- 指令细节
  - movq(数据传送指令): irmovq,rrmovq,mrmovq,rmmovq定义了源和目标的格式，立即数(i),寄存器(r),内存(m)
  - OPg(整数操作指令)：addq,subq,andq,xorq只对寄存器进行操作，包含三个条件码ZF,SF,OF(零,符号,溢出)
  - jxx(跳转指令)：jmp,jle,jl,je,jne,jpe
  - comvxx(条件传送指令)：cmovle,cmovl,cmove,cmovne,cmovge,cmovg
  - call返回地址入栈，跳到目的地址，ret从该调用中返回
  - pushq和popq执行入栈和出栈
  - halt执行停止指令

##### Y86-64 异常
- 程序可见的状态码stat
  - AOK：正常操作
  - HLT：遇到机器执行halt指令
  - ADR：遇到非法地址
  - INS：遇到非法指令

